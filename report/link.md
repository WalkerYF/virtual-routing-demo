# 使用tcp模拟链路层

这里写一下如何使用tcp来模拟链路层的实现。

## 适用网络物理拓扑结构

注意，为了简化问题，下面的链路层的实现仅限于这样的网络拓扑结构。

1. 多台路由器之间通过网线直连，中间没有其他的主机。

![](figure/2018-05-11-17-03-55.png)

## 接口

链路层应该给网络层提供以下接口

### 发送网络层的数据

网络层有IP包需要发送的时候，会将IP包送至链路层进行发送。
链路层会屏蔽线路中的各种细节，将该IP包发送至对应IP的主机。

1. 子网内不同IP地址的主机之间数据的发送

```py
DataLinkLayer.send(ip_pkg: bytes) -> error_code : int
# 将这个ip_pkg从该主机发往另一个主机
```

其中链路层会读取ip_pkg中的源ip和目的ip，并且尝试发送。
其中src_host是本机ip，dest_host是需要发送的主机的ip。

### 将链路层上收到的IP包向上交给网络层

链路层上的多个端口，都可能会收到IP包，链路层的工作是将这些IP包向上发送至网络层，由网络层进行解析。

```py
DataLinkLayer.receive()  -> ip_pkb : bytes
# 阻塞式收取IP包，会收到一个bytes类型的IP包
```

## IP package的格式

链路层应该按照以下的方式解析IP package，获取源ip和目的ip
注意：网络层保证给到链路层的ip包中的源IP和目的IP在同一个子网内。

参考标准IP数据包的格式
![](figure/2018-05-11-16-56-31.png)

其中选项固定为空，即没有

于是ip包的首部大小为5*32比特

|比特范围|值|
|-|-|
|0-15|/|
|16-31|数据包长度|
|32-47|/|
|48-63|子网比特数|
|64-95|/|
|96-127|源IP地址|
|128-159|最终目的IP地址|
|128-159|下一跳IP地址|

## 链路层底层实现

### 初始化链路

1. 使用host_register来初始化路由器间的链路
    1. host_register接受一个interface列表
    1. 拿到的每一个interface
        1. 每个interface建立一个监听线程
            1. 监听线程会accpet得到一个用于接受其他路由信息的socket
        1. 每个interface尝试连接对方
            1. 得到一个用于发送路由的socket
    1. 网线算是连上了

注意，这个host_register只适用于初始化路由器物理拓扑的过程。

TODO:暂时不能够处理网络中间拓扑改变的情况

1. 拔掉网线，一台路由器掉线？
1. 一台新的路由器想连网线

### send

由于链路层维护着每一个interface对应的socket
只需要找到对应的interface，然后使用其中的counter_socket发送即可。 

### receive

每一个interface都会有一个接受package的线程，它会从interface的client_socket中不断尝试接受IP包，一旦收到IP包，就会将这个IP包放到链路层的队列中，网络层就可以直接调用recv函数得到链路层收到的IP包